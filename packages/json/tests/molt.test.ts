/**
 * Tests for unified Molt API
 */

import { describe, it, expect } from 'vitest';
import { molt, detectDirty, hasTypeMetadata } from '../src/molt.js';
import { serialize } from '../src/serializer.js';

describe('detectDirty', () => {
  it('should detect single-line comments', () => {
    expect(detectDirty('{ // comment\n "key": "value" }')).toBe(true);
  });

  it('should detect multi-line comments', () => {
    expect(detectDirty('{ /* comment */ "key": "value" }')).toBe(true);
  });

  it('should detect single quotes', () => {
    expect(detectDirty("{ 'key': 'value' }")).toBe(true);
  });

  it('should detect unquoted keys', () => {
    expect(detectDirty('{ key: "value" }')).toBe(true);
    expect(detectDirty('{ _key: "value" }')).toBe(true);
    expect(detectDirty('{ $key: "value" }')).toBe(true);
  });

  it('should detect trailing commas in objects', () => {
    expect(detectDirty('{ "key": "value", }')).toBe(true);
  });

  it('should detect trailing commas in arrays', () => {
    expect(detectDirty('[ 1, 2, 3, ]')).toBe(true);
  });

  it('should not detect valid JSON as dirty', () => {
    expect(detectDirty('{"key":"value"}')).toBe(false);
    expect(detectDirty('{"key":123}')).toBe(false);
    expect(detectDirty('[1,2,3]')).toBe(false);
  });

  it('should handle edge cases', () => {
    // Strings containing patterns that look dirty but are actually valid
    expect(detectDirty('{"url":"http://example.com"}')).toBe(true); // Contains //
    expect(detectDirty('{"code":"if (x) { /* do something */ }"}')).toBe(true); // Contains /* */
  });
});

describe('hasTypeMetadata', () => {
  it('should detect TypedJSON format with metadata', () => {
    const typedJSON = {
      json: { date: '2024-01-01T00:00:00.000Z' },
      meta: { values: { '.date': 'Date' } },
    };
    expect(hasTypeMetadata(typedJSON)).toBe(true);
  });

  it('should detect TypedJSON format without metadata', () => {
    const typedJSON = {
      json: { name: 'alice', age: 30 },
    };
    expect(hasTypeMetadata(typedJSON)).toBe(true);
  });

  it('should not detect regular objects', () => {
    expect(hasTypeMetadata({ name: 'alice', age: 30 })).toBe(false);
    expect(hasTypeMetadata({ data: { key: 'value' } })).toBe(false);
  });

  it('should handle primitives', () => {
    expect(hasTypeMetadata(null)).toBe(false);
    expect(hasTypeMetadata(undefined)).toBe(false);
    expect(hasTypeMetadata(42)).toBe(false);
    expect(hasTypeMetadata('string')).toBe(false);
  });

  it('should handle edge cases', () => {
    // Object with json field but also other fields
    expect(hasTypeMetadata({ json: {}, other: 'field' })).toBe(false);
    expect(hasTypeMetadata({ json: {}, meta: { values: {} } })).toBe(true);
  });
});

describe('molt - auto mode', () => {
  it('should parse valid JSON', () => {
    const result = molt('{"name":"alice","age":30}');
    expect(result).toEqual({ name: 'alice', age: 30 });
  });

  it('should auto-detect and clean dirty JSON', () => {
    const result = molt("{ name: 'alice', age: 30 }");
    expect(result).toEqual({ name: 'alice', age: 30 });
  });

  it('should auto-detect and restore types', () => {
    const date = new Date('2024-01-01');
    const input = JSON.stringify(serialize({ date, count: 42 }));
    const result = molt<{ date: Date; count: number }>(input);

    expect(result.count).toBe(42);
    expect(result.date).toBeInstanceOf(Date);
    expect(result.date.toISOString()).toBe(date.toISOString());
  });

  it('should handle dirty JSON with types', () => {
    // This is a theoretical case - dirty JSON with type metadata
    // In practice, type metadata is usually generated by serialize()
    const dirty = `{
      json: { date: '2024-01-01T00:00:00.000Z', count: 42 },
      meta: { values: { 'date': 'Date' } }
    }`;

    const result = molt<{ date: Date; count: number }>(dirty);
    expect(result.count).toBe(42);
    expect(result.date).toBeInstanceOf(Date);
  });

  it('should not over-process valid JSON without types', () => {
    // This should be fast path - no dirty cleaning, no type restoration
    const result = molt('{"simple":"json"}');
    expect(result).toEqual({ simple: 'json' });
  });
});

describe('molt - explicit modes', () => {
  it('should respect dirty: "never"', () => {
    // Should not clean, will throw on dirty JSON
    expect(() => molt("{ name: 'alice' }", { dirty: 'never' }))
      .toThrow();
  });

  it('should respect dirty: "always"', () => {
    // Should always clean, even if input looks valid
    const result = molt('{"name":"alice"}', { dirty: 'always' });
    expect(result).toEqual({ name: 'alice' });
  });

  it('should respect typed: "never"', () => {
    const input = JSON.stringify(serialize({ date: new Date('2024-01-01') }));
    const result = molt(input, { typed: 'never' });

    // Should not restore types
    expect(result).toHaveProperty('json');
    expect(result).toHaveProperty('meta');
  });

  it('should respect typed: "always"', () => {
    // Even without metadata, won't break (just returns as-is)
    const result = molt('{"name":"alice"}', { typed: 'always' });
    expect(result).toEqual({ name: 'alice' });
  });

  it('should handle combined never modes', () => {
    const result = molt('{"name":"alice"}', { dirty: 'never', typed: 'never' });
    expect(result).toEqual({ name: 'alice' });
  });
});

describe('molt.fast', () => {
  it('should parse valid JSON directly', () => {
    const result = molt.fast('{"name":"alice"}');
    expect(result).toEqual({ name: 'alice' });
  });

  it('should fail on dirty JSON', () => {
    expect(() => molt.fast("{ name: 'alice' }")).toThrow();
  });

  it('should not restore types', () => {
    const input = JSON.stringify(serialize({ date: new Date('2024-01-01') }));
    const result = molt.fast(input);

    // Should not restore types
    expect(result).toHaveProperty('json');
    expect(result).toHaveProperty('meta');
  });
});

describe('molt.dirty', () => {
  it('should clean dirty JSON', () => {
    const result = molt.dirty("{ name: 'alice', age: 30 }");
    expect(result).toEqual({ name: 'alice', age: 30 });
  });

  it('should not restore types', () => {
    const dirty = `{
      json: { date: '2024-01-01T00:00:00.000Z' },
      meta: { values: { '.date': 'Date' } }
    }`;

    const result = molt.dirty(dirty);
    // Should clean but not restore types
    expect(result).toHaveProperty('json');
    expect(result).toHaveProperty('meta');
  });
});

describe('molt.typed', () => {
  it('should restore types from TypedJSON', () => {
    const date = new Date('2024-01-01');
    const input = JSON.stringify(serialize({ date, count: 42 }));
    const result = molt.typed<{ date: Date; count: number }>(input);

    expect(result.count).toBe(42);
    expect(result.date).toBeInstanceOf(Date);
  });

  it('should fail on dirty JSON', () => {
    expect(() => molt.typed("{ name: 'alice' }")).toThrow();
  });
});

describe('molt.full', () => {
  it('should apply all transformations', () => {
    const dirty = `{
      json: { date: '2024-01-01T00:00:00.000Z', count: 42 },
      meta: { values: { 'date': 'Date' } }
    }`;

    const result = molt.full<{ date: Date; count: number }>(dirty);
    expect(result.count).toBe(42);
    expect(result.date).toBeInstanceOf(Date);
  });
});

describe('molt.stringify', () => {
  it('should stringify with auto type detection', () => {
    const date = new Date('2024-01-01');
    const result = molt.stringify({ date, count: 42 });
    const parsed = JSON.parse(result);

    // Should include type metadata
    expect(parsed).toHaveProperty('json');
    expect(parsed).toHaveProperty('meta');
    expect(parsed.meta.values.date).toBe('Date');
  });

  it('should not include metadata for plain objects', () => {
    const result = molt.stringify({ name: 'alice', age: 30 });
    const parsed = JSON.parse(result);

    // Should be regular JSON
    expect(parsed).not.toHaveProperty('meta');
    expect(parsed).toEqual({ name: 'alice', age: 30 });
  });

  it('should respect typed: "never"', () => {
    const result = molt.stringify({ date: new Date() }, { typed: 'never' });
    const parsed = JSON.parse(result);

    // Should not include metadata
    expect(parsed).not.toHaveProperty('meta');
    expect(parsed).toHaveProperty('date');
  });

  it('should respect typed: "always"', () => {
    const result = molt.stringify({ name: 'alice' }, { typed: 'always' });
    const parsed = JSON.parse(result);

    // Always mode includes TypedJSON wrapper even without metadata
    expect(parsed).toHaveProperty('json');
    expect(parsed.json).toEqual({ name: 'alice' });
  });

  it('should handle space formatting', () => {
    const result = molt.stringify({ name: 'alice' }, { space: 2 });
    expect(result).toContain('\n');
    expect(result).toContain('  ');
  });
});

describe('molt - validation', () => {
  it('should validate with schema', () => {
    const schema = {
      parse: (value: unknown) => {
        const obj = value as Record<string, unknown>;
        if (typeof obj.name !== 'string') {
          throw new Error('name must be string');
        }
        if (typeof obj.age !== 'number') {
          throw new Error('age must be number');
        }
        return value;
      },
    };

    const result = molt('{"name":"alice","age":30}', { validate: schema });
    expect(result).toEqual({ name: 'alice', age: 30 });
  });

  it('should throw on validation failure', () => {
    const schema = {
      parse: (value: unknown) => {
        const obj = value as Record<string, unknown>;
        if (typeof obj.name !== 'string') {
          throw new Error('name must be string');
        }
        return value;
      },
    };

    expect(() => molt('{"name":123}', { validate: schema }))
      .toThrow('name must be string');
  });
});

describe('molt - complex scenarios', () => {
  it('should handle nested objects with types', () => {
    const data = {
      user: {
        name: 'alice',
        createdAt: new Date('2024-01-01'),
        id: 123456789012345678901n,
      },
      metadata: {
        version: 1,
        tags: ['a', 'b'],
      },
    };

    const json = molt.stringify(data);
    const result = molt(json);

    expect(result).toEqual(data);
    expect(result.user.createdAt).toBeInstanceOf(Date);
    expect(typeof result.user.id).toBe('bigint');
  });

  it('should handle arrays with mixed types', () => {
    const data = {
      items: [
        { date: new Date('2024-01-01'), value: 1 },
        { date: new Date('2024-01-02'), value: 2 },
      ],
    };

    const json = molt.stringify(data);
    const result = molt(json);

    expect(result.items).toHaveLength(2);
    expect(result.items[0].date).toBeInstanceOf(Date);
    expect(result.items[1].date).toBeInstanceOf(Date);
  });

  it('should handle large objects efficiently', () => {
    const data = {
      items: Array.from({ length: 1000 }, (_, i) => ({
        id: i,
        value: i * 10,
        name: `Item ${i}`,
      })),
    };

    const json = molt.stringify(data, { typed: 'never' });
    const result = molt(json, { typed: 'never' });

    expect(result.items).toHaveLength(1000);
    expect(result.items[500].id).toBe(500);
  });

  it('should handle maxSize limit', () => {
    const largeInput = '{"data":"' + 'x'.repeat(1000) + '"}';

    expect(() => molt(largeInput, { maxSize: 100, dirty: 'always' }))
      .toThrow('Input too large');
  });
});

describe('molt - edge cases', () => {
  it('should handle empty objects', () => {
    expect(molt('{}')).toEqual({});
  });

  it('should handle empty arrays', () => {
    expect(molt('[]')).toEqual([]);
  });

  it('should handle null', () => {
    expect(molt('null')).toBe(null);
  });

  it('should handle primitives', () => {
    expect(molt('42')).toBe(42);
    expect(molt('"hello"')).toBe('hello');
    expect(molt('true')).toBe(true);
    expect(molt('false')).toBe(false);
  });

  it('should handle special characters', () => {
    expect(molt('{"text":"Hello\\nWorld"}')).toEqual({ text: 'Hello\nWorld' });
    expect(molt('{"emoji":"ðŸ‘"}')).toEqual({ emoji: 'ðŸ‘' });
  });

  it('should handle deeply nested structures', () => {
    const deep = { a: { b: { c: { d: { e: { f: 'value' } } } } } };
    const json = molt.stringify(deep, { typed: 'never' });
    const result = molt(json, { typed: 'never' });

    expect(result).toEqual(deep);
  });
});
